package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.0.0"

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
)

var requireUnimplemented *bool

type generator struct {
}

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-grpc-gateway-interceptor %v\n", version)
		return
	}
	g := &generator{}

	var flags flag.FlagSet
	requireUnimplemented = flags.Bool("require_unimplemented_servers", true, "set to false to match legacy behavior")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(g.Generate)
}

func (g *generator) Generate(plugin *protogen.Plugin) error {
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	for _, f := range plugin.Files {
		// 跳过没有定义 service 的 proto 文件
		if len(f.Services) == 0 {
			continue
		}
		if !f.Generate {
			continue
		}

		// 指定要生成的文件名，策略可以根据需要指定
		fname := f.GeneratedFilenamePrefix + ".pb.gw.inter.go"
		// 告诉 protoc 要生成一个新文件，并获取一个引用，后面可以通过 t 来写入新文件的内容
		t := plugin.NewGeneratedFile(fname, f.GoImportPath)

		// 生成 import
		t.P("// Code generated by protoc-gen-grpc-gateway-interceptor. DO NOT EDIT.")
		t.P("// versions:")
		t.P("// - protoc-gen-grpc-gateway-interceptor v", version)
		t.P("// - protoc                               ", protocVersion(plugin))
		t.P()
		if f.Proto.GetOptions().GetDeprecated() {
			t.P("// ", f.Desc.Path(), " is a deprecated file.")
		} else {
			t.P("// source: ", f.Desc.Path())
		}
		t.P()
		t.P("package ", f.GoPackageName)
		t.P()

		g.generateService(t, plugin, f)
	}
	return nil
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (g *generator) generateService(t *protogen.GeneratedFile, plugin *protogen.Plugin, file *protogen.File) {
	for _, s := range file.Services {
		if len(s.Methods) == 0 {
			continue
		}
		serviceName := s.GoName + "WithInterceptor"
		t.P()
		t.P("// ", serviceName, " implements ", s.GoName, " interface with interceptor")
		t.P("type ", serviceName, " struct {")
		if *requireUnimplemented {
			t.P("    Unimplemented", s.GoName, "Server")
		}
		t.P("   unaryInter  ", grpcPackage.Ident("UnaryServerInterceptor"))
		t.P("   streamInter ", grpcPackage.Ident("StreamServerInterceptor"))
		t.P("   server      ", s.GoName, "Server")
		t.P("}")
		t.P()
		t.P("// Register", s.GoName, " returns a new ", serviceName, " instance")
		t.P("func Register", s.GoName, "(srv ", s.GoName, "Server, unaryInter ", grpcPackage.Ident("UnaryServerInterceptor"), ", streamInter ", grpcPackage.Ident("StreamServerInterceptor"), ")", s.GoName, "Server {")
		t.P("    return &", serviceName, "{")
		t.P("        unaryInter:  unaryInter,")
		t.P("        streamInter: streamInter,")
		t.P("        server:      srv,")
		t.P("    }")
		t.P("}")
		t.P()
		g.generateMethods(t, plugin, file, s, serviceName)
	}
}

func (g *generator) generateMethods(t *protogen.GeneratedFile, plugin *protogen.Plugin, file *protogen.File, service *protogen.Service, serviceName string) {
	funcPrefix := "func (srv *" + serviceName + ") "
	for _, m := range service.Methods {
		t.P()
		t.P("// ", m.GoName, " implements with interceptor")
		t.P(funcPrefix, serverSignature(t, m), " {")

		if !m.Desc.IsStreamingClient() && !m.Desc.IsStreamingServer() {
			// Unary RPC method
			fullMethod := fmt.Sprintf("/%s/%s", service.Desc.FullName(), m.Desc.Name())
			t.P("    if srv.unaryInter == nil {")
			t.P("        return srv.server.", m.GoName, "(ctx, req)")
			t.P("    }")
			t.P("    info := &", grpcPackage.Ident("UnaryServerInfo"), "{")
			t.P("        Server:     srv,")
			t.P("        FullMethod: \"", fullMethod, "\",")
			t.P("    }")
			t.P("    handler := func(ctx ", contextPackage.Ident("Context"), ", req interface{}) (interface{}, error) {")
			t.P("        return srv.server.", m.GoName, "(ctx, req.(*", m.Input.Desc.Name(), "))")
			t.P("    }")
			t.P("    resp, err := srv.unaryInter(ctx, req, info, handler)")
			t.P("    if err != nil {")
			t.P("        return nil, err")
			t.P("    }")
			t.P("    return resp.(*", m.Output.Desc.Name(), "), nil")
			t.P("}")
			t.P()
			continue
		}

		// Streaming RPC method
		t.P("    if srv.streamInter == nil {")
		if m.Desc.IsStreamingClient() {
			t.P("    return srv.server.", m.GoName, "(stream)")
		} else if m.Desc.IsStreamingServer() {
			t.P("    return srv.server.", m.GoName, "(req, stream)")
		}
		t.P("    }")
		t.P("    info := &", grpcPackage.Ident("StreamServerInfo"), "{")
		t.P("       FullMethod: \"/", service.Desc.FullName(), "/", m.Desc.Name(), "\",")
		t.P("       IsClientStream: ", m.Desc.IsStreamingClient(), ",")
		t.P("       IsServerStream: ", m.Desc.IsStreamingServer(), ",")
		t.P("    }")
		t.P("    handler := func(s interface{}, ss ", grpcPackage.Ident("ServerStream"), ") error {")
		if m.Desc.IsStreamingClient() {
			t.P("       return s.(*", serviceName, ").server.", m.GoName, "(stream)")
		} else if m.Desc.IsStreamingServer() {
			t.P("       return s.(*", serviceName, ").server.", m.GoName, "(req, stream)")
		}
		t.P("    }")
		t.P("    return srv.streamInter(srv, stream, info, handler)")

		t.P("}")
		t.P()
	}
}

func serverSignature(t *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+t.QualifiedGoIdent(contextPackage.Ident("Context")))
		ret = "(*" + t.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "req *"+t.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "stream "+method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
